<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesticulate - GOD LEVEL SUPREME üî•</title>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- MediaPipe Hands - Latest Version with WASM SIMD -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js"
        crossorigin="anonymous"></script>
    <!-- GSAP for smooth transitions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <style>
        :root {
            --primary: #4e9aff;
            --success: #00ff88;
            --glass: rgba(10, 10, 10, 0.7);
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #030303;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            color: white;
            touch-action: none;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* DEBUG CANVAS - shows hand tracking overlay */
        #debug-canvas {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 150px;
            border-radius: 15px;
            border: 2px solid var(--primary);
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            box-shadow: 0 5px 30px rgba(78, 154, 255, 0.4);
        }

        @media (max-width: 600px) {
            #debug-canvas {
                width: 120px;
                height: 90px;
                top: auto;
                bottom: 150px;
                left: 10px;
            }
        }

        /* Minimal UI Components */
        .glass-panel {
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 20px;
            pointer-events: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        /* Shape Panel - Top Right (Desktop), Collapsible Bottom (Mobile) */
        #shape-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            padding: 15px;
            width: 240px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
        }

        h1 {
            margin: 0;
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--primary);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            transition: opacity 0.3s ease;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            color: #bbb;
            padding: 10px 5px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        button.active {
            background: rgba(78, 154, 255, 0.4);
            border-color: var(--primary);
            color: white;
        }

        /* Tooltip Legend - Bottom Left */
        #legend-panel {
            position: absolute;
            bottom: 25px;
            left: 20px;
            z-index: 90;
            padding: 12px 18px;
            max-width: 280px;
            font-size: 0.75rem;
        }

        .legend-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #aaa;
        }

        .legend-icon {
            font-size: 1rem;
            width: 22px;
            text-align: center;
        }

        /* Status & Mobile Specific */
        #tracking-status {
            position: absolute;
            bottom: 25px;
            right: 20px;
            font-size: 0.65rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 30px;
            border: 1px solid var(--border);
            color: #ff4e4e;
            transition: all 0.3s ease;
        }

        #tracking-status.active {
            color: var(--success);
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .toggle-icon {
            font-size: 1.2rem;
            opacity: 0.6;
            transition: transform 0.3s ease;
        }

        /* Overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .start-btn {
            background: var(--primary);
            color: white;
            padding: 18px 45px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 800;
            border: none;
            letter-spacing: 0.1em;
            box-shadow: 0 10px 30px rgba(78, 154, 255, 0.3);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(78, 154, 255, 0.5);
        }

        #loading-text {
            color: #666;
            font-size: 0.7rem;
            font-weight: 600;
            margin-top: 20px;
            letter-spacing: 0.2em;
        }

        /* Color Pill */
        .color-pill {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: none;
            cursor: pointer;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border-radius: 50%;
            border: 1px solid #fff;
        }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 600px) {
            #shape-panel {
                top: auto;
                bottom: 20px;
                right: 15px;
                left: 15px;
                width: auto;
                padding: 12px;
            }

            #legend-panel {
                display: none;
            }

            .collapsed .legend-content,
            .collapsed .controls-grid,
            .collapsed .color-pill {
                display: none;
            }

            .collapsed {
                padding: 10px 15px;
                border-radius: 30px;
            }

            .collapsed .panel-header {
                margin-bottom: 0;
            }

            .collapsed .toggle-icon {
                transform: rotate(-90deg);
            }

            #tracking-status {
                top: 10px;
                bottom: auto;
                right: 10px;
            }
        }

        /* Loading animation */
        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .loading {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>

<body>

    <div id="start-overlay">
        <button class="start-btn" onclick="startApp()">üñêÔ∏è START EXPERIENCE</button>
        <p id="loading-text">GOD LEVEL HAND TRACKING üî•</p>
    </div>

    <div id="container"></div>

    <!-- Debug canvas to show hand tracking -->
    <canvas id="debug-canvas"></canvas>

    <div id="legend-panel" class="glass-panel collapsed" onclick="togglePanel('legend-panel')">
        <div class="panel-header">
            <h1>Hand Guide</h1>
            <span class="toggle-icon">‚ñæ</span>
        </div>
        <div class="legend-content">
            <div class="legend-item"><span class="legend-icon">üñêÔ∏è</span> <span>Show hand to wake</span></div>
            <div class="legend-item"><span class="legend-icon">‚ÜïÔ∏è</span> <span>Move to translate</span></div>
            <div class="legend-item"><span class="legend-icon">üîÑ</span> <span>Tilt to rotate</span></div>
            <div class="legend-item"><span class="legend-icon">ü§è</span> <span>Open/Close to zoom</span></div>
        </div>
    </div>

    <div id="shape-panel" class="glass-panel collapsed" onclick="togglePanel('shape-panel')">
        <div class="panel-header">
            <h1>Transform</h1>
            <span class="toggle-icon">‚ñæ</span>
        </div>
        <div class="controls-grid">
            <button onclick="setShape('heart', event)" id="btn-heart">Heart</button>
            <button onclick="setShape('flower', event)" id="btn-flower">Flower</button>
            <button onclick="setShape('saturn', event)" id="btn-saturn">Saturn</button>
            <button onclick="setShape('buddha', event)" id="btn-buddha">Buddha</button>
            <button onclick="setShape('fireworks', event)" id="btn-fireworks">Fireworks</button>
            <button onclick="setShape('sphere', event)" id="btn-sphere" class="active">Sphere</button>
        </div>
        <div class="color-pill" onclick="event.stopPropagation()">
            <span style="font-size: 0.65rem; color: #888; font-weight: 700; letter-spacing: 0.1em;">TINT</span>
            <input type="color" id="colorPicker" value="#4e9aff">
        </div>
    </div>

    <div id="tracking-status">INITIALIZING...</div>

    <video id="webcam" style="display:none;" autoplay playsinline muted></video>

    <script>
        // ============================================================
        // GOD LEVEL SUPREME HAND TRACKING ENGINE üî•
        // ============================================================

        // Detect mobile for performance optimization
        const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const PARTICLE_COUNT = IS_MOBILE ? 3000 : 6000;  // Less particles on mobile for smooth FPS

        let scene, camera, renderer, particleSystem, controls;
        let currentShape = 'sphere';

        // Hand tracking state with ENHANCED smoothing
        let handTension = 0.5, lerpedTension = 0.5;
        let handPos = { x: 0, y: 0 }, lerpedHandPos = { x: 0, y: 0 };
        let handRotation = 0, lerpedHandRotation = 0;
        let baseColor = new THREE.Color(0x4e9aff);

        // Tracking stats for debugging
        let trackingStats = {
            framesProcessed: 0,
            handsDetected: 0,
            lastDetectionTime: 0,
            fps: 0
        };

        // Debug canvas context
        let debugCtx = null;
        const debugCanvas = document.getElementById('debug-canvas');

        // Smooth lerp factor - HIGHER = more responsive, LOWER = smoother
        const LERP_FACTOR = 0.15;
        const ROTATION_LERP = 0.12;

        function togglePanel(id) {
            document.getElementById(id).classList.toggle('collapsed');
        }

        function initDebugCanvas() {
            debugCtx = debugCanvas.getContext('2d');
            // Set internal resolution
            debugCanvas.width = 320;
            debugCanvas.height = 240;
        }

        function drawDebugOverlay(landmarks, image) {
            if (!debugCtx) return;

            const ctx = debugCtx;
            const w = debugCanvas.width;
            const h = debugCanvas.height;

            // Clear and draw mirrored video frame
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(image, -w, 0, w, h);
            ctx.restore();

            if (landmarks && landmarks.length > 0) {
                const lm = landmarks[0];

                // Draw connections (skeleton)
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4],  // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8],  // Index
                    [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                    [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [5, 9], [9, 13], [13, 17] // Palm
                ];

                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;

                connections.forEach(([start, end]) => {
                    ctx.beginPath();
                    ctx.moveTo((1 - lm[start].x) * w, lm[start].y * h);
                    ctx.lineTo((1 - lm[end].x) * w, lm[end].y * h);
                    ctx.stroke();
                });

                // Draw landmarks
                ctx.shadowBlur = 15;
                lm.forEach((point, idx) => {
                    const x = (1 - point.x) * w;
                    const y = point.y * h;

                    // Fingertips are brighter
                    if ([4, 8, 12, 16, 20].includes(idx)) {
                        ctx.fillStyle = '#ff4e4e';
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (idx === 0) {
                        // Wrist - special marker
                        ctx.fillStyle = '#4e9aff';
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                ctx.shadowBlur = 0;
            }

            // Draw FPS and stats
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, w, 20);
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 11px monospace';
            ctx.fillText(`FPS: ${trackingStats.fps} | DETECTS: ${trackingStats.handsDetected}`, 5, 14);
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enableZoom = false;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            generateSphere(positions);

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.08, vertexColors: true, transparent: true,
                opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            updateColors();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updateColors() {
            const colors = particleSystem.geometry.attributes.color.array;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const c = new THREE.Color(baseColor).multiplyScalar(0.4 + Math.random() * 0.6);
                colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b;
            }
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }

        // Generators
        function generateSphere(arr, r = 4) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                arr[i * 3] = r * Math.cos(theta) * Math.sin(phi);
                arr[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                arr[i * 3 + 2] = r * Math.cos(phi);
            }
        }

        function generateHeart(arr) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                arr[i * 3] = x * 0.25; arr[i * 3 + 1] = y * 0.25; arr[i * 3 + 2] = (Math.random() - 0.5) * 5;
            }
        }

        function generateFlower(arr) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = 4 * Math.cos(5 * t);
                const phi = Math.random() * Math.PI * 2;
                arr[i * 3] = r * Math.cos(t) * Math.cos(phi);
                arr[i * 3 + 1] = r * Math.sin(t) * Math.cos(phi);
                arr[i * 3 + 2] = r * Math.sin(phi) * 0.5;
            }
        }

        function generateSaturn(arr) {
            const ring = Math.floor(PARTICLE_COUNT * 0.4);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < ring) {
                    const phi = Math.acos(-1 + (2 * i) / ring), theta = Math.sqrt(ring * Math.PI) * phi;
                    arr[i * 3] = 2.5 * Math.cos(theta) * Math.sin(phi);
                    arr[i * 3 + 1] = 2.5 * Math.sin(theta) * Math.sin(phi);
                    arr[i * 3 + 2] = 2.5 * Math.cos(phi);
                } else {
                    const a = Math.random() * Math.PI * 2, d = 3.5 + Math.random() * 3;
                    arr[i * 3] = Math.cos(a) * d; arr[i * 3 + 1] = (Math.random() - 0.5) * 0.5; arr[i * 3 + 2] = Math.sin(a) * d;
                }
            }
        }

        function generateBuddha(arr) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const s = Math.random();
                if (s < 0.2) { // Head
                    const p = Math.random() * Math.PI * 2, t = Math.random() * Math.PI;
                    arr[i * 3] = 0.8 * Math.sin(t) * Math.cos(p); arr[i * 3 + 1] = 0.8 * Math.sin(t) * Math.sin(p) + 2.5; arr[i * 3 + 2] = 0.8 * Math.cos(t);
                } else if (s < 0.7) { // Body
                    const p = Math.random() * Math.PI * 2, t = Math.random() * Math.PI;
                    arr[i * 3] = 2.2 * Math.sin(t) * Math.cos(p); arr[i * 3 + 1] = 2.2 * Math.sin(t) * Math.sin(p); arr[i * 3 + 2] = 2.2 * Math.cos(t) * 0.8;
                } else { // Base
                    const a = Math.random() * Math.PI * 2, r = 3.5 * Math.sqrt(Math.random());
                    arr[i * 3] = r * Math.cos(a); arr[i * 3 + 1] = (Math.random() - 0.5) * 0.8 - 3; arr[i * 3 + 2] = r * Math.sin(a);
                }
            }
        }

        function generateFireworks(arr) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2, p = Math.random() * Math.PI, r = Math.pow(Math.random(), 0.1) * 8;
                arr[i * 3] = r * Math.sin(p) * Math.cos(t); arr[i * 3 + 1] = r * Math.sin(p) * Math.sin(t); arr[i * 3 + 2] = r * Math.cos(p);
            }
        }

        function setShape(shape) {
            currentShape = shape;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + shape).classList.add('active');
            const temp = new Float32Array(PARTICLE_COUNT * 3);
            if (shape === 'sphere') generateSphere(temp); else if (shape === 'heart') generateHeart(temp);
            else if (shape === 'flower') generateFlower(temp); else if (shape === 'saturn') generateSaturn(temp);
            else if (shape === 'buddha') generateBuddha(temp); else if (shape === 'fireworks') generateFireworks(temp);

            const posAttr = particleSystem.geometry.attributes.position;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                gsap.to(posAttr.array, {
                    duration: 1.5, ease: "power3.out",
                    [i * 3]: temp[i * 3], [i * 3 + 1]: temp[i * 3 + 1], [i * 3 + 2]: temp[i * 3 + 2],
                    onUpdate: () => { if (i === 0) posAttr.needsUpdate = true; }
                });
            }
        }

        // ============================================================
        // GOD LEVEL MEDIAPIPE SETUP üî•
        // ============================================================

        let hands = null;
        let mpCamera = null;
        let isProcessing = false;
        let lastFrameTime = performance.now();

        function initMediaPipe() {
            const loadingText = document.getElementById('loading-text');
            loadingText.classList.add('loading');
            loadingText.textContent = 'LOADING AI MODEL...';

            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                }
            });

            // GOD LEVEL SETTINGS üî•
            hands.setOptions({
                selfieMode: true,
                maxNumHands: 1,
                modelComplexity: 1,  // 0 = Lite, 1 = Full (more accurate)
                minDetectionConfidence: 0.7,  // HIGHER = less false positives
                minTrackingConfidence: 0.6    // HIGHER = more stable tracking
            });

            hands.onResults(onHandResults);

            return hands.initialize().then(() => {
                loadingText.textContent = 'AI MODEL READY ‚úì';
                console.log('üî• GOD LEVEL MediaPipe initialized!');
            });
        }

        function onHandResults(results) {
            const now = performance.now();
            const delta = now - lastFrameTime;
            lastFrameTime = now;
            trackingStats.fps = Math.round(1000 / delta);
            trackingStats.framesProcessed++;

            const st = document.getElementById('tracking-status');

            // Draw debug overlay
            drawDebugOverlay(results.multiHandLandmarks, results.image);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                st.innerText = "üñêÔ∏è TRACKING";
                st.classList.add('active');
                trackingStats.handsDetected++;
                trackingStats.lastDetectionTime = now;

                const lm = results.multiHandLandmarks[0];

                // ENHANCED position calculation - use palm center for stability
                const palmX = (lm[0].x + lm[5].x + lm[17].x) / 3;
                const palmY = (lm[0].y + lm[5].y + lm[17].y) / 3;
                handPos.x = (palmX - 0.5) * 35;  // Removed negative - now follows hand naturally
                handPos.y = -(palmY - 0.5) * 25;

                // ENHANCED tension calculation using 3D distance
                let totalDist = 0;
                const fingertips = [4, 8, 12, 16, 20];
                fingertips.forEach(idx => {
                    const dx = lm[idx].x - lm[0].x;
                    const dy = lm[idx].y - lm[0].y;
                    const dz = (lm[idx].z || 0) - (lm[0].z || 0);
                    totalDist += Math.sqrt(dx * dx + dy * dy + dz * dz);
                });

                // Normalize tension to 0.2 - 2.5 range
                const avgDist = totalDist / 5;
                handTension = Math.max(0.2, Math.min(2.5, (avgDist - 0.05) / 0.35 * 2));

                // ENHANCED rotation using index finger direction
                const dx = lm[9].x - lm[0].x;
                const dy = lm[9].y - lm[0].y;
                handRotation = Math.atan2(dy, dx) + Math.PI / 2;

            } else {
                // Grace period before resetting
                if (now - trackingStats.lastDetectionTime > 500) {
                    st.innerText = "NO HAND";
                    st.classList.remove('active');
                    // Smooth return to default
                    handTension = handTension * 0.95 + 0.5 * 0.05;
                }
            }

            isProcessing = false;
        }

        async function startCamera() {
            const videoElement = document.getElementById('webcam');
            const statusEl = document.getElementById('tracking-status');

            statusEl.innerText = "STARTING CAMERA...";

            // Detect mobile for optimized settings
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            try {
                // Request camera with optimal settings - lower for mobile
                const constraints = {
                    video: {
                        width: { ideal: isMobile ? 320 : 640, max: isMobile ? 480 : 1280 },
                        height: { ideal: isMobile ? 240 : 480, max: isMobile ? 360 : 720 },
                        facingMode: 'user',
                        frameRate: { ideal: isMobile ? 20 : 30, max: 30 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;

                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });

                console.log('üì∑ Camera started:', stream.getVideoTracks()[0].getSettings());
                statusEl.innerText = "CAMERA READY";

                // Start processing frames
                processFrames();

            } catch (err) {
                console.error('Camera error:', err);
                statusEl.innerText = "CAMERA ERROR";
                statusEl.style.color = '#ff4e4e';

                // Retry once
                setTimeout(async () => {
                    try {
                        const fallbackStream = await navigator.mediaDevices.getUserMedia({ video: true });
                        videoElement.srcObject = fallbackStream;
                        await videoElement.play();
                        processFrames();
                    } catch (e) {
                        alert('Camera access required! Please allow camera permissions and refresh.');
                    }
                }, 1000);
            }
        }

        async function processFrames() {
            const videoElement = document.getElementById('webcam');

            async function loop() {
                if (!isProcessing && videoElement.readyState >= 2) {
                    isProcessing = true;
                    try {
                        await hands.send({ image: videoElement });
                    } catch (e) {
                        console.warn('Frame processing error:', e);
                        isProcessing = false;
                    }
                }
                requestAnimationFrame(loop);
            }

            loop();
        }

        async function startApp() {
            const overlay = document.getElementById('start-overlay');
            const loadingText = document.getElementById('loading-text');

            loadingText.textContent = 'INITIALIZING...';
            loadingText.classList.add('loading');

            // Initialize debug canvas
            initDebugCanvas();

            // Initialize Three.js
            initThree();
            requestAnimationFrame(animate);

            // Initialize MediaPipe
            await initMediaPipe();

            // Hide overlay
            overlay.style.display = 'none';

            // Start camera
            await startCamera();
        }

        function animate() {
            requestAnimationFrame(animate);

            // ENHANCED smooth interpolation
            lerpedTension += (handTension - lerpedTension) * LERP_FACTOR;
            lerpedHandPos.x += (handPos.x - lerpedHandPos.x) * LERP_FACTOR;
            lerpedHandPos.y += (handPos.y - lerpedHandPos.y) * LERP_FACTOR;
            lerpedHandRotation += (handRotation - lerpedHandRotation) * ROTATION_LERP;

            if (particleSystem) {
                particleSystem.scale.setScalar(0.5 + lerpedTension * 2);
                particleSystem.position.set(lerpedHandPos.x, lerpedHandPos.y, 0);
                particleSystem.rotation.z = lerpedHandRotation;
                particleSystem.rotation.y += 0.005;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        document.getElementById('colorPicker').addEventListener('input', e => {
            baseColor.set(e.target.value);
            updateColors();
        });
    </script>
</body>

</html>
